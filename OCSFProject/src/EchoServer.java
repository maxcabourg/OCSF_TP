// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {	//Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	private ChatIF serverUI;	private static String QUIT_COMMAND = "#quit";	private static String SET_PORT_COMMAND = "#setport";	private static String START_COMMAND = "#start";	private static String STOP_COMMAND = "#stop";	private static String CLOSE_COMMAND = "#close";	private static String GETPORT_COMMAND = "#getport";	private static String LOGIN_COMMAND = "#login";	private String[] commandes = { QUIT_COMMAND,			START_COMMAND, SET_PORT_COMMAND,			CLOSE_COMMAND, GETPORT_COMMAND, STOP_COMMAND, LOGIN_COMMAND};	//Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port) 	{		super(port);	}	public EchoServer(int port, ChatIF chatIF) 	{		super(port);		this.serverUI = chatIF;		try {			listen();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	//Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient	(Object msg, ConnectionToClient client)	{		String message = (String) msg;		if(!client.getInfo("nbCommandes").equals(0) && message.split(" ")[0].equals(LOGIN_COMMAND)){			try {				client.sendToClient("Please login at the beginning");				client.close();			} catch (IOException e1) {				// TODO Auto-generated catch block				e1.printStackTrace();			}		}		else{			client.setInfo("nbcommandes", 1);			serverUI.display("Message received: " + msg + " from " + client);			if((message.equals("#quit"))){				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}			}			else if(message.split(" ")[0].equals(LOGIN_COMMAND)){				client.setInfo("name", ((String)msg).split(" ")[1]);				System.out.println(client.getInfo("name"));			}else{				this.sendToAllClients( (client.getInfo("name") == null )? msg:client.getInfo("name")+": "+msg);			}		}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	protected void serverStarted()	{		System.out.println		("Server listening for connections on port " + getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverStopped()	{		System.out.println		("Server has stopped listening for connections.");	}	protected void clientConnected(ConnectionToClient client){		client.setInfo("nbCommandes", 0);		serverUI.display("New client connected "+client.getName());	}	synchronized protected void clientDisconnected(			ConnectionToClient client){		serverUI.display(client.getName()+" disconnected");	}	synchronized protected void clientException(			ConnectionToClient client, Throwable exception){  		serverUI.display("Exception thrown by a client");		clientDisconnected(client);	}	//Class methods ***************************************************	/**	 * This method is responsible for the creation of 	 * the server instance (there is no UI in this phase).	 *	 * @param args[0] The port number to listen on.  Defaults to 5555 	 *          if no argument is entered.	 */	public static void main(String[] args) 	{		int port = 0; //Port to listen on		try		{			port = Integer.parseInt(args[0]); //Get port from command line		}		catch(Throwable t)		{			port = DEFAULT_PORT; //Set port to 5555		}		EchoServer sv = new EchoServer(port);		try 		{			sv.listen(); //Start listening for connections		} 		catch (Exception ex) 		{			System.out.println("ERROR - Could not listen for clients!");		}	}	public void handleMessageFromAdmin(String message) {		serverUI.display("Message received from admin : "+message);		try {			if(isCommand(message) != null){				if(message.equals(QUIT_COMMAND)){					this.close();				}				else if(message.equals(STOP_COMMAND)){					if(this.isListening())						stopListening();					else						serverUI.display("Already stoped listening connections");				}				else if(message.equals(CLOSE_COMMAND)){					if(this.isListening())						stopListening();					Thread[] clientThreads = this.getClientConnections();					for(Thread client: clientThreads){						clientDisconnected((ConnectionToClient)client);						((ConnectionToClient)client).close();											}				}				else if(message.equals(START_COMMAND)){					if(!this.isListening())						this.listen();					else						serverUI.display("Already listening");				}				else if(message.equals(GETPORT_COMMAND)){					serverUI.display("Port = "+this.getPort());				}				else if(message.split(" ")[0].equals(SET_PORT_COMMAND)){					String port = message.split(" ")[1];					if(port.matches("[1-9]^4")){						this.setPort(Integer.parseInt(port));					}					else						System.out.println("Invalid command");								}			}			else if(message.equals("42")){				this.sendToAllClients("   /\\_/\\  ");				this.sendToAllClients("  / o o \\  ");				this.sendToAllClients(" (   \"   ) ");				this.sendToAllClients("  \\~(*)~/  ");				this.sendToAllClients("   // \\\\  ");			}		} catch (IOException e) {			serverUI.display("Could not receive message");		}		this.sendToAllClients("From admin : "+message);	}	private String isCommand(String message) {		if (message.charAt(0) == '#') {			String command = message.split(" ")[0];			for (String element : commandes) {				if (command.equals(element))					return command;			}		}		return null;	}}//End of EchoServer class